---
title: "[논문 리뷰] Linear Matching of JavaScript Regular Expressions"
published: False
excerpt: "Aurèle Barrière and Clément Pit-Claudel. 2024. Linear Matching of JavaScript Regular Expressions. Proc. ACM
Program.Lang.8, PLDI, Article 201 (June 2024), 25 pages."
---

---

# 논문 리뷰를 시작하며

프로그래밍 언어 특론 강의 과제로 논문 리뷰 세미나를 하게 되었다. 논문 리스트는 언어 관련 논문들이기에 내가 연구하고자 하는 주제들과는 직접적인 연관성이 높은 논문은 없었다.
그중에서 선별하여 JavaScript에 관한 논문을 선정하였고, 이는 현재 연구 중인 DASH가 .js로 구현되며, 이는 js의 최적화 등의 개선이 DASH, 또는 어플리케이션 레이어 단의 작업에 효율을 높여줄 수 있을 것이라 생각했기 때문이다.

논문의 분량도 25장으로 꽤나 많고, 언어 관련으로는 개인적으로 공부하며 깊게 생각해본 적이 없어서 어려울 것 같지만, 최선을 다할 생각이다.

늘 하고 싶은 것만 할 수는 없으니까!

[Linear Matching of JavaScript Regular Expressions](https://doi.org/10.1145/3656431)

> 본 게시글은 위 논문을 스스로 번역, 재정리한 내용을 포함합니다.

---

# 한글 번역 및 코멘트
## Abstract

현대의 정규표현식 언어는, 잘 이해되고 있는 전통적인 정규표현식에서 크게 벗어났다. 
이들은 Matching problem을 근본적으로 변화시키는 기능들을 포함하고 있다. 
이러한 기능을 얻는 대신, 현대의 정규표현식 엔진은 때때로 "Exponential complexity blowups" 지수적 복잡도 폭발을 겪으며, 이는 JavaScript 애플리케이션에서 자주 발생하는 서비스 거부, DoS 취약점의 원인이 되기도 한다. 
더욱이, 정규표현식의 Semantics는 언어마다 달라지며, 이러한 차이가 알고리즘 설계나 worst-case complexity에 미치는 영향은 거의 연구되지 않았다.

본 논문은 JavaScript 정규표현식의 의미에 대한 새로운 관점을 제시한다. 
이를 통해 우리는 지금까지 알려졌던 것보다 "더 넓은 부분 집합"이 선형 시간으로 매칭 가능하다는 사실을 밝혀냈다. 
그 과정에서 기존 최신 알고리즘들이 의미적으로 틀렸거나, 초선형 복잡도로 비효율적이거나, 혹은 과도하게 보수적이어서 선형 매칭이 불가능한 수준인 여러 사례를 발견하였다. 
우리는 이러한 문제를 해결하고, 선형 복잡도를 회복하기 위해 새로운 알고리즘을 제안한다.

또한 lookaround(lookahead/lookbehind)를 non-backtracking 방식으로 선형 시간에 매칭할 수 있는 최초의 알고리즘을 제시함으로써, 선형 정규표현식 매칭 분야의 최신 기술 수준을 한층 더 끌어올린다.  
하나는 모든 정규표현식 언어에서 **captureless lookbehind**를 지원하고, 다른 하나는 JavaScript의 특성을 활용하여 **unrestricted lookahead/lookbehind**를 지원한다. 
마지막으로, 정규표현식 엔진에 대한 시간 복잡도 및 공간 복잡도 사이의 새로운 trade-off도 제시한다.

제안한 모든 알고리즘은 실제로 구현 가능한 수준이며, 이를 프로토타입 구현을 통해 검증하였고, 이 중 일부는 Chrome과 Node.js에 사용되는 V8 JavaScript 엔진에 실제로 병합되었다.

---

### Notes

* Matching Problem: 정규표현식이 주어졌을 때, 특정 입력 문자열이 해당 정규표현식에 의해 정의되는 언어에 속하는지를 판별하는 과정. 즉, 이 문자열이 이 정규표현식에 맞는가?
```
정규표현식 R = /(ab)+c/
입력 문자열 w = "abababc"
→ Matching Problem: "abababc"는 /(ab)+c/에 매치되는가?
→ 정답: 예 (True)
```
* Backtracking: 정규표현식 매칭 시, 가능한 모든 경로를 탐색하는 방식으로, 실패 시 분기점으로 되돌아가 재시도함. 직관적이지만 입력에 따라 지수 시간 소요 가능.
* Lookaround (Lookahead / Lookbehind): 문자열의 일치 여부를 앞이나 뒤의 문자열 맥락에 따라 판단하는 고급 정규표현식 기능. 전통적인 DFA로는 직접 지원 불가.
* Linear-time matching: 정규표현식을 O(n) 시간에 매칭하는 능력. DFA 기반에서는 이론적으로 가능하지만, 현대 regex의 확장 기능들로 인해 현실에서는 어렵다.  
  현대의 정규표현식 언어는 lookaround 등으로 정규 언어의 경계를 넘는 표현력을 가짐으로, Matching Problem의 해결 방식에 따라 실행 시간 복잡도가 선형 O(n), 지수 O(2^n)일 수도 있음.
* ReDoS (Regular Expression Denial-of-Service): 악의적인 입력을 통해 정규표현식 매칭 엔진의 최악의 시간 복잡도를 유도하여 서비스 거부 상태를 초래하는 공격.

현대 정규표현식 언어는 전통적인 DFA 기반의 정규 언어 모델을 넘는 기능들을 포함하여, Matching Problem의 해결이 복잡하고 비효율적일 수 있음. 
특히 JavaScript의 정규표현식 엔진은 backtracking 기반으로 동작하여 Exponential Complexity 문제에 취약하고, 이것이 ReDoS 공격의 주요 원인이 됨. 

또 언어 별로 정규표현식의 Semantics가 다르며, 이로 인해 실제 매칭 알고리즘의 동작 방식과 복잡도에 미치는 영향이 충분히 연구되지 않음.

JavaScript의 정규표현식 Semantics를 연구, 선형 시간 매칭이 불가능하다고 여겨졌던 부분을 "더 넓은 영역"에서 선형 시간으로 처리할 수 있음을 밝힘.

기존 알고리즘들이 의미적으로 틀렸거나, 비효율적, 혹은 필요 이상으로 제한적인 가정에 기반하고 있었음을 보이고, 이를 보완하는 새로운 접근 제안.

특히 lookaround까지 포함하는 패턴은 **non-backtracking** 방식으로 선형 시간에 처리하는 새로운 알고리즘을 제시함.

제안된 알고리즘은 실제로 구현, 일부는 Chrome, Node.js의 V8 JavaScript 엔진에 병합되어 실용적 기여가 입증됨.

---

## **I. Introduction**

전통적인 정규표현식(문자, 연결, 선택, *만으로 구성된 정규 표현식)의 표현력과 계산 복잡도는 잘 알려져 있다. 
표현력 관점에서 이는 **finite automata**와 정확히 동일한 표현력을 갖는 것으로 알려져 있다. 
계산 복잡도의 관점에서는, Matching Problem에서 전처리 시간과 매칭 시간 사이의 고전적인 trade-off가 존재한다. 
예를 들어, 정규표현식 r에 대해서 **DFA(Deterministic Finite Automata)** 를 구성하면, 최악의 경우 시간 복잡도는 **O(2^|_r_|)** 이지만, 이후의 매칭은 **O(|_s_|)** 시간에 수행할 수 있다. 
여기서 |_r_|, |_s_|는 각각 정규표현식과 입력 문자열의 길이다. 
반대로, DFA의 determinization cost를 피하고자 한다면, 정규표현식 r에 대해 **NFA(Nondeterministic Finite Automata)** 를 **O(|_r_|)** 시간에 구성할 수 있으며, 이후 매칭은 최악의 경우 **O(|_r_| x |_s_|)** 시간에 수행된다. 

우리는 전통적인 정규표현식과 구분하기 위해 현대 정규표현식을 **regexes**라 부르며, 이들은 조상 격인 전통 정규표현식에서 **상당히 멀어진 형태**이다. 
표현력과 복잡도 면에서는 훨씬 강력해졌지만, **그만큼 학문적으로는 충분히 연구되지 않았다.** 
이러한 비전통적인 기능들 덕분에 regexes는 프로그래밍에서 가장 광범위하게 내장된 도메인 특화 언어 (embedded DSL, Domain-Specific Languages) 중 하나가 되었다. 
한 연구에 따르면, regexes는 npm 및 PyPI 패키지의 30% 이상에서 발견되었고, 또 다른 연구에서는 Python 개발의 42%에서 사용되었으며, 상위 10개 TIOBE 언어 중 8개가 이를 네이티브로 지원한다고 한다. 
이러한 기능 중 특히 중요한 확장은 **capture group**의 도입이다. 
캡처 그룹은 현대 정규표현식 엔진이 단순히 **매칭이 있는지를 확인하는 것을 넘어서, 괄호로 감싼 각 하위 표현식이 입력 문자열의 어떤 부분과 일치했는지**를 함께 반환할 수 있게 만든다.
예를 들어, regex /(a*)b/를 입력 문자열 "caabd"에 적용하면, 현대 정규표현식 엔진은 전체 매치 결과로 "aab"를 반환할 뿐 아니라, 캡처 그룹 /(a*)/에 대해서는 "aa"라는 서브 매치 결과를 함께 반환한다. 
이처럼 **캡처 그룹의 존재는 문제의 본질을 근본적으로 바꾼다.** 
전통적인 정규표현식 매칭은 단지 **입력 문자열이 특정 형식 언어에 속하는지를 검사하는 것**이었다면, 현대의 정규표현식 매칭은 **정규표현식과 내부 캡처 그룹 각각이 어떤 부분 문자열과 매치되는지를 계산하는 과정**이다. 
따라서 **현대 정규표현식(regexes)** 는 단순한 언어 인식 수단이 아닌, **텍스트를 검색하고 분절하는 도구로 기능한다.** 
이 문제는 종종 **모호성(ambiguity)** 를 수반하기 때문에, 현대 정규표현식 언어는 **하나의 문자열이 여러 방식으로 매치될 수 있는 경우에도 결과를 결정적으로 분해(disambiguate)** 하기 위해 **우선 순위 규칙(priority rules)** 를 정의한다.
예를 들어, regex /(a|a*)/를 문자열 "aa"에 매칭하는 경우, 대부분의 현대 정규표현식 엔진은 **선택 연산자(alternation)** 의 왼쪽 분기를 우선시하며, 첫 번째 문자 하나만 매칭 결과로 반환한다(이는 일반적으로 어휘 분석기(lexer)에서 사용하는 최장 매치(longest-match) 의미론과는 다르다). 

기타 현대 정규표현식 기능으로는 **backreference, lookaround, anchor, character class, repetition** 등이 있다. 
**Backreference**는 정규표현식의 후반부가 앞에서 캡처된 그룹과 **정확히 같은 문자열**과 일치하도록 강제한다. 
예를 들어 정규표현식 /(a*)b\1/은 "aabaa"와는 매치되지만 "aaba"와는 매치되지 않는다. 
이는 \1이 첫 번째 그룹 /(a*)/에서 캡처된 문자열 전체와 정확히 일치해야 하기 때문이다. 
**Lookaround**는 **문자열을 소비하지 않고, 매칭의 조건만 부여하는 방식**이다. 
예를 들어 정규표현식 /(?<=£)1/은 "£1.2"에서는 "1"에 매치되지만, "v1.2"에서는 아무 것도 매치되지 않는다. 
여기서 후방탐색 lookbehind가 검사하는 "£" 문자는 **최종 매칭 결과에는 포함되지 않는다.**  
**Anchors** ^, $, \b는 **각각 문자열의 시작, 끝, 단어 경계에서 매치**되며, **character classes** 는 **문자 범위**와 일치한다. (예: [a-e]는 문자 a부터 e까지 중 하나와 매치됨) 
**Repetition**은 같은 정규표현식을 여러번 반복시킨다.
예를 들어 (a|b){4,8}은 문자 a와 b의 조합 중 **4회 이상, 8회 이하 반복되는 패턴**과 일치한다. 
이러한 기능들을 조합했을 때의 편리함을 보여주는 예로, 정규표현식 /(?<=PLDI)[0-9]{2,4}/는 "PLDI2024"에서 "2024" 부분을 매치시켜, PLDI 논문 참조의 연도를 추출할 수 있다. 

이러한 **비전통적인 기능들 및 그 상호작용**에 대해서 현재로서는 **부분적으로만 이해되고 있는 상태**이다. 
예를 들어, **backreference는 정규표현식 매칭 문제를 NP-hard로 만든다**는 사실은 잘 알려져 있다. 
반대로 **capture groups, anchor, character classes**와 같은 기능들은 **선형 시간 알고리즘이 실제로 널리 사용되고 있다**.  
하지만, 그 중간 영역에는 **여전히 불확실성이 존재한다**. 
우리가 아는 한, **lookaround, capture group이 결합된 경우**와 같은 조합에 대해서는 **정규표현식 매칭 복잡도에 대한 명확한 이론적 결과가 존재하지 않는다**. 
이로 인해, **현대 정규표현식 엔진들은 두 가지 유형으로 나뉘게 된다**. 
1. **Backtracking 기반 엔진**:  
    backreference를 포함하여 모든 기능을 지원하지만, **전통적 기능들로만 구성된 단순한 패턴조차** 선형 알고리즘이 존재함에도 불구하고, 알고리즘이 **Exponential-time complexity** 폭발을 일으킬 수 있음.  

이러한 **worst-case performance**는 **보안적으로 심각한 문제**로 이어질 수 있으며, **일부 기능 장애에서부터 대규모 웹사이트 전체가 다운되는 사태**에 이르기까지 다양한 영향을 미친다. 
실제로 한 연구에 따르면, **JavaScript 기반 웹 서버의 약 12%가 ReDos(정규표현식 기반 서비스 거부 공격)** 에 취약한 것으로 나타났다. 

이러한 **보안상의 우려와 복잡도 문제**로 인해, **최악의 경우에도 선형 시간 보장을 제공하는 정규표현식 엔진**에 대한 관심이 다시 높아지고 있다.  
이러한 엔진은 그 대가로 **기능 집합을 제한**하는데, 예를 들어 **backreference와 lookaround를 아예 지원하지 않는 경우**도 있다. 
이러한 **선형 엔진에 대한 관심은 점차 패러다임의 전환**으로 이어지고 있다. 
점점 더 많은 플랫폼과 언어들이 다음 두 가지 방향 중 하나를 따르고 있다. 
* **기본적으로 선형 엔진만을 사용하는 방식** (Rust, Go, RE2 라이브러리를 사용하는 모든 언어)
* 최소한, **정규표현식의 일부분에 대해서 선형 엔진으로 전환할 수 있는 옵션을 제공하는 방식** (.NET)

본 논문은 이와 같은 **패러다임 전환이 JavaScript에서도 적용 가능**하다는 점을 보이며, **표현력 측면의 손해도 기존에 생각했던 것보다 훨씬 작다**는 사실을 입증한다. 

그러나 안타깝게도, **요즘처럼 더 안전한 정규표현식 환경이 조성된 상황에서도,** 여전히 **"선형(linear)"** 이라는 표현은 **많은 의미적 차이를 내포**하고 있다. 
예를 들어, 일부 엔진(.NET)은 **입력 문자열 길이 |_s_|에 대해서만 선형이면 충분**하다고 보고, **O(|_r_|^2 x |_s_|)** 시간의 매칭 수행도 수용 가능한 것으로 간주한다. 
반면, 다른 엔진들(Rust)은 **정규표현식의 길이 |_r_|과 입력 문자열의 길이 |_s_| 모두에 대해 선형 시간 실행**을 보장하려 하며, 이러한 특성 덕분에 **사용자가 제공하거나 동적으로 생성한 정규표현식을 처리하는 데 적합하다.** (Google Sheets는 사용자 입력 기반 정규표현식을 RE2로 평가함) 
우리의 연구는 **정규표현식 길이와 입력 문자열 길이 모두에 대해 선형 성능을 동시에 달성**한다.

설상가상으로, **각기 다른 정규표현식 언어들은 이러한 비전통적인 기능들에 대해 서로 다른 Semantic design을 선택한다.** 
그 결과, **한 언어용으로 작성된 regex는 다른 언어에서 그대로 사용할 수 없는 경우가 많다.** 
예를 들어, **quantifiers: x, +, ?, ,)** 나 **capture groups**는 **JavaScript와 Perl 간에도 의미가 다르고,**, .NET이나 JavaScript에서 유효한 많은 **lookaround 표현식**은 **Python, Perl, Java**에서는 유효하지 않다 (이들 언어에서는 /((?<=ba*))처럼 lookaround 안에 quantifier를 사용하는 것을 허용하지 않음). 
하지만, **이러한 Semantic design 선택이 정규표현식 매칭 복잡도에 어떤 영향을 미치는지에 대해서는 아직 명확히 이해되지 않았다.**

이 문제는 여러 가지 웅요한 결과를 초래한다. 
**프로그래밍 언어 설계 관점**에서 보면 상황은 매우 심각하다. 
우리가 **표현력이 풍부하면서도 안전한 정규표현식 언어**를 설계하고자 한다면, 각각의 **비전통적인 기능**에 대해, 그리고 각 기능이 **채택된 semantic design 선택** 하에서의 **worst-case complexity**를 더 잘 이해해야 한다. 
**프로그래밍 언어 구현 관점**에서도 상황은 나아지지 않는다. 
실무에서 **충분히 이해되었다고 여겨졌던 기능들과 의미조차도,** 우리의 연구 결과, **여러 실제 구현체들이 잘못된 알고리즘적 가정**에 기반하고 있음이 드러났다. 
특히, 우리는 다음과 같은 사실을 발견했다. 
* 일반적으로 **선형 시간으로 매칭이 불가능하다고 여겨졌던 기능들**이 사실은 **선형 엔진으로도 지원 가능**하다는 것
* **선형이라고 간주되었던 알고리즘들이 실제로는 그렇지 않았다**는 것
* **현대 정규표현식 언어에 적용 가능한 것으로 여겨졌던 구현 알고리즘들이 실제로는 의미적으로 잘못된 결과**를 내고 있었다는 것

이후의 섹션들에서는 이 세 가지 경우 각각에 대한 **구체적인 사례**들을 제시할 것이다. 

우리의 연구는 **JavaScript 정규표현식 언어**에 초점을 맞추고 있으며, 그 의미론(Semantics)은 **ECMAScript 표준**에 따라 **슈도코드 형식의 backtracking 알고리즘**으로 정의되어 있다. 
JavaScript는 **capture group**, **backreference**, **lookaround**를 포함한 다양한 **비전통적인 정규표현식 기능**을 지원하지만, 그 의미론은 다른 언어들과 구분되는 **특이한 선택들**을 포함하고 있으며, 이는 **매칭 복잡도에도 영향을 미친다**. 
우리가 확인한 모든 **JavaScript 정규표현식 엔진들**은 단 하나를 제외하고 모두 **backtracking 기반 구현 전략**을 사용하고 있다. 
예외는 **V8**이며, 이는 Google Chrome과 Node.js에서 사용되는 JavaScript 엔진이다. 
V8은 두 개의 엔진을 갖고 있다. 
하나는 **Irregexp**라 불리는, 모든 기능을 갖춘 **backtracking 엔진**이고, 다른 하나는 우리가 **"V8Linear"** 라 부르는 **선형 시간 정규표현식 엔진**이다. 
이 엔진은 **backreference와 lookaround를 제외한 대부분의 JavaScript 정규표현식 구성 요소**를 지원하며, **명령행 플래그를 통해 활성화**할 수 있다. 
우리가 아는 한, **V8Linear는 JavaScript 정규표현식의 유의미한 부분집합에 대해 산업 수준의 선형 시간 구현을 제공하는 유일한 사례**이다. 

우리의 연구는 다음과 같은 **연구 질문들**에 답하고자 한다. 
1. **JavaScript 정규표현식 언어 중 어떤 부분이 최악의 경우에도 선형 시간 복잡도로 매칭 가능한가?**
2. **정규표현식의 크기(|_r_|)와 입력 문자열의 크기(|_s_|) 모두에 대해 선형성(linearity)**, 즉 **O(|_r_| x |_s_|)** 의 시간 복잡도를 달성할 수 있는가?
3. **JavaScript에서 채퇵된 의미론적 선택들**은 어떤 기능이 선형적으로 매칭 가능한지에 **얼마나 큰 영향을 미치는가?**

우리의 기여는 다음과 같이 요약될 수 있다. 
* 우리는 JavaScript 정규표현식의 의미적 특성에 대한 **새로운 이해를 제공**한다. 
구체적으로, **선형 시간 O(|_r_| x |_s_|)으로 매칭 가능한 JavaScript 정규표현식의 큰 부분집합**을 식별하였다. 
우리는 **nullable quantifier(x, +, ?)**에 대한 JavaScript의 의미가 기존의 선형 매칭 기법과 **호환되지 않음**을 보여주고, 이를 선형성으로 확장하기 위한 적응 방법을 제안한다. 
또한 **nullable plus 연산자와 quantifier 내부의 캡처 그룹**과 같은 JavaScript 기능들이 **V8Linear에서 정규표현식 길이에 대해 선형으로 구현되지 않았음**을 확인하였고, 이 기능들 대부분을 **선형적으로 처리할 수 있는 새로운 알고리즘**을 제시한다. 
* 우리는 **lookaround을 위한 최초의 non-backtracking 알고리즘**을 제안하며, 기존의 선형 엔진들이 기능 선택에 있어서 **너무 보수적**이었다는 점을 보여준다. 
우리는 **캡처 그룹이 없는 lookbehind**를 JavaScript의 의미와 무관하게 **선형 시간에 매칭하는 알고리즘**을 제안하며, 이는 다른 정규표현식 언어에도 적용 가능하다. 
이어서, JavaScript 고유의 의미론적 특성을 활용해 **캡처 그룹이 포함된 unrestricted lookaround**도 **선형 시간에 매칭 가능한 방법**을 제시한다. 
단, 이 경우 **추가적인 메모리 복잡도**가 수반된다. 
우리가 아는 한, **캡처 그룹이 포함된 lookaround에 대해 선형 알고리즘을 제안하고 실제로 구현한 것은 이번이 처음이다.**
* 우리는 제안된 모든 알고리즘에 대해 **실질적인 구현을 제공**하며, 그것들이 일반적으로 적용 가능하고, 복잡도도 실험을 통해 검증될 수 있음을 보인다. 
우리는 여러 알고리즘을 **V8Linear에 실제로 구현**했으며, 그 중 일부는 **V8에 병합되어 릴리즈되었다.** 
또한 본 논문에 제시된 모든 알고리즘을 포괄하는 **OCaml 프로토타입 구현**도 제공하였으며, 이를 통해 **JavaScript 정규표현식의 매우 넓은 부분집합을 지원**할 수 있다. 
이 프로토타입은 구현 실험을 위한 **이상적인 테스트 환경**을 제공하며, **캡처 그룹에 대해 시간 복잡도와 공간 복잡도 사이의 새로운 trade-off**를 실증하는 데 사용되었다.

![Table 1](https://github.com/user-attachments/assets/5986f4b9-1aca-4b29-8933-8a193c08cbab)

Nullable 수량자: 기존 V8Linear는 잘못 구현되어 있음 → 본 논문: 선형 시간 달성
수량자 내부의 캡처 그룹: 기존에는 O(|r|² × |s|) → 본 논문은 선형 시간
Nullable/Non-nullable Plus: 기존에는 지수 시간 → 본 논문은 선형 시간
Lookbehind (캡처 없는): 기존 V8Linear는 미지원 → 본 논문은 선형 시간 알고리즘 제안
Unrestricted Lookaround: 기존 미지원 → 본 논문은 선형 시간 가능 (단, 메모리 비용 필요)

이 표는 본 논문의 주요 결과를 요약한 것이다.
전체적으로 보면, JavaScript 정규표현식의 상당히 넓은 부분집합이 입력 문자열과 정규표현식 길이 모두에 대해 선형 시간으로 매칭 가능함을 보여준다.

---
### Notes


* **Matching Problem:**  
정규표현식이 주어졌을 때, 특정 문자열이 해당 표현식과 일치하는지를 결정하는 문제.
전통적 정규표현식에서는 입력 문자열이 정규 언어에 속하는지를 DFA/NFA 기반으로 판단함. 
하지만 현대 정규표현식에서는 **capture group, lookaround** 등의 영향으로 **위치 정보 추출 및 조건 검사** 문제로 확장됨. 
* **Regex vs Regexes:**  
  * **regex**: 정규표현식 하나 (특정 패턴)
  * **regexes**: 전통적 정규표현식과 구분하기 위해 명명된 **현대 정규표현식 전체 시스템**, 특히 lookaround, backreference 등을 포함하는 확장된 모델  
* **Capture Group:**  
  ()로 감싸진 하위 표현식에 대해, **입력 문자열 중 일치한 부분을 따로 기억하고 반환**하는 기능.  
  이로 인해 정규표현식은 단순한 인식 도구에서 **텍스트 분절 및 추출 도구**로 진화함.
* **Backreference:**  
  이전에 캡처된 그룹의 문자열을 뒤에서 **정확히 재사용**하도록 강제함.  
  정규 언어 표현력을 넘어서는 기능으로, Matching Problem을 **NP-hard**로 만듦.
* **Lookaround (Lookahead / Lookbehind):**  
  주변 컨텍스트를 검사하지만 **실제 매칭 문자열에는 포함되지 않는 조건부 검사 기능.**  
  전통적인 DFA로는 처리 불가하며, 특히 lookbehind는 구현이 매우 어려움.
* **Nullable Quantifier / Plus:**  
  * *, +, ?와 같이 반복되거나 생략될 수 있는 연산자.
  * 특히 JavaScript에서의 의미(예: greedy한 nullable plus)는 전통 DFA 방식과 충돌되며, 선형 매칭 기법을 적용하려면 별도 조정이 필요함.
* **Backtracking vs Linear Engine:**  
  * Backtracking 엔진: 가능한 모든 경로를 시도하며 실패 시 되돌아가는 방식. 표현력은 높지만 **최악의 경우 지수 시간.**
  * Linear 엔진: **모든 입력에 대해 O(|r| × |s|) 시간 보장**. 표현력은 제한적이지만 보안에 유리함 (ReDoS 방어).
* **Semantic Design Divergence:**  
  정규표현식의 각 기능(lookaround, quantifier 등)의 **동작 의미가 언어마다 다름.**
  예: Python은 lookbehind 안의 quantifier를 허용하지 않음 → 같은 정규표현식이 다른 언어에서는 동작하지 않음.
* **ReDoS (Regular Expression Denial of Service):**    
  악의적인 입력으로 backtracking 엔진의 **최악 경로를 유도해 지수 시간 실행**을 발생시킴으로써,
  서비스를 마비시키는 공격.


기존의 DFA/NFA 기반 정규표현식은 표현력, 복잡도, 매칭 속도 간 trade-off가 명확함.  

현대 정규표현식은 capture group, backreference, lookaround 등으로 인해 **정규 언어 모델을 넘어선 새로운 표현력** 가지게 됨.
이에 따라 현대 정규표현식의 **매칭 문제는 단순한 언어 인식이 아닌 위치 추출, 조건 금증까지 포함하는 복잡한 문제**가 됨.

이들 기능은 실제 코드베이스(npm, PyPI 등)에서 **광범위하게 사용되고 있음**에도 불구하고, **표현력 증가에 따른 계산 복잡도와 의미론적 정의의 불일치로 인해** 학술적, 실용적으로 모두 미비한 상태였음. 

현대 엔진은 대부분 backtracking 기반으로, **복잡한 기능을 지원하지만 성능과 보안 문제가 존재함.**

이로 인해 최근에는 기능을 제한하더라도 **항상 선형 시간을 보장하는 엔진**에 대한 관심이 높아지고 있음(Rust, Go, RE2).

**이러한 패러다임의 전환을 JavaScript에 적용 가능하다는 것을 입증함.**

하지만, **현실에서는 선형 시간 자체에 대한 정의가 구현마다 달라지고**, 정규표현식과 입력 문자열 길이 모두에 대해 선형인지 여부는 구현별로 차이가 있음.

JavaScript는 ECMA-262에 따라 정의되며, 의미론이 특이하고 일부 기능은 타 언어와 호환되지 않음.
→ 따라서 정규표현식 복잡도에 **언어 설계의 의미론이 실제로 영향을 주는가?** 라는 질문이 중요해짐.

* 핵심  
  1. JavaScript 정규표현식 언어 중 어떤 기능이 선형 시간에 매칭 가능한가?
  2. 정규표현식과 문자열 길이 모두에 대해서 선형 시간 복잡도를 달성할 수 있는가?
  3. JavaScrip의 의미론적 선택이 선형 매칭 가능성에 어떤 영향을 미치는가?

---
## **II. Linear Regex Engines Background**

![Fig 1. Recursive Thompson NFA constructions for a, e1e2, e1|e2 and e*](https://github.com/user-attachments/assets/b731ebb2-88b4-4670-945c-78804a4dc12a)

우리의 기여를 명확히 하기 위해, 이 섹션에서는 **일반적으로 사용되는 정규표현식 매칭 알고리즘에 대한 간략한 개요**를 제시한다. 

전통적인 정규표현식은 **NFA (Nondeterministic Finite Automaton)** 로 표현할 수 있다. 
이때 NFA는 **𝜀-전이(ε-transition)** 와, 문자열에서 읽어야 할 **문자로 레이블된 전이(transitions)** 의 조합으로 구성된다. 

정규표현식이 문자열과 매칭된다는 것은, 해당 문자열을 구성하는 레이블 전이들이 따라갈 수 있는 경로(path)가 NFA 상에 존재함을 의미한다.

**Figure 1**은 전통적인 정규표현식에 대해 **Thompson Construction** 방법 [Thompson 1968]을 요약하여 보여준다(다른 형태의 구성법도 존재한다 [Gluškov 1961]). 

전통적인 정규표현식의 크기를 |_r_|라고 할 때, (여기서 |_r_|는 텍스트로 표현한 정규표현식이 사용하는 문자 수를 의미한다) 
**Thompson NFA를 구성하는 데에는 O(|_r_|) 시간 복잡도**가 소요되며, **상태(state)와 전이(transition)의 수 또한 O(|_r_|)** 만큼 생성된다.

이 논문의 나머지 부분에서는, **정규표현식(regex)**과 **그에 대응하는 Thompson NFA를 동일한 것으로 간주하여** 사용할 것이며, 따라서 **정규표현식의 상태(state)라고 하면 NFA의 상태**를 의미한다.


![Fig 2. Tagged NFA and its corresponding bytecodefor/(a|.)b/. Thebytecoderepresentation is explained later in Section3.3.](https://github.com/user-attachments/assets/31b6fffb-8a51-473d-aaed-8558379c5b2f)

이 전통적인 구성(Thompson NFA) **캡처 그룹(capture groups)** 을 다루기 위해 확장될 수 있다.

첫 번째로, **여러 개의 outgoing edge(출발하는 간선)** 을 가지는 노드에 대해 **edge priority(간선 우선순위)** 개념을 추가하여, **어떤 경로를 먼저 고려해야 하는지를 명시한다.**

두 번째로, **효과를 가지는 노드(effectful nodes)** 를 추가하여, **각 캡처 그룹이 입력 문자열의 어느 위치에서 시작되고 종료되는지를 기록**한다. 

이러한 **태그가 부착된 NFA(tagged NFA)** 의 예시는 Figure 2에 나와 있으며, 해당 그림과 본 논문의 나머지 부분에서는 **점선 화살표(dotted arrows)** 가 **우선 순위가 높은 간선**을 나타낸다.

특히, **#1: entry 노드를 통과하는 경로**는 **첫 번째 캡처 그룹에 들어간 시점의 문자열 위치**를 기록한다.


**Backtracking 엔진**은 해당 정규표현식에 대응하는 **NFA의 모든 경로를 우선순위에 따라 열거(enumerate)** 하며, **가장 먼저 accept하는 경로**를 반환하는 방식으로 정규표현식을 매칭한다. 

이러한 기법은 모든 **정규표현식 기능(backreference, lookaround 등)을 단순히 지원할 수 있도록 확장**될 수 있지만, **문자열 크기에 대해 최악의 경우 지수 시간 복잡도**를 가진다. 
그리고 이 경우, **전통적인 정규표현식 기능만 사용한 regex**에서도 발생할 수 있다.

**Backreference**가 없는 경우, **lookaround** 및 몇몇 다른 기능들을 제외할 경우, **Linear Engine**은 다음과 같은 통찰을 이용해 **선형 시간 복잡도**를 달성할 수 있다.


**Uniform-futures property**:  
오토마타의 두 경로 접두사(prefix) p<sub>1</sub>과 p<sub>2</sub>를 생각해보자. 
이 둘이 **같은정규표현식 상태**에 도달했고, **입력 문자열의 동일한 접두 부분**을 읽을 상태라면, p<sub>1</sub>을 완전한 경로로 확장한 모든 경우는 **p<sub>2</sub>의 유효한 확장**이기도 하다.

캡처 그룹이 존재하는 경우, 만약 p<sub>1</sub>이, p<sub>2</sub>보다 **우선순위가 높다면,** p<sub>1</sub>의 어떤 확장도 항상 p2의 확장보다 **우선순위가 높다.**

즉, 어떤 경로 접두사의 "미래(future)"는 **현재의 정규표현식 상태와 현재의 입력 문자열 위치**에 의해서만 결정된다.

이 속성을 설명하기 위해, 정규표현식 /(a+)*/b를 문자열 "aaa"에 대해 실행하는 예를 생각해보자. 
여기서 p<sub>1</sub>은 "a" 두 개를 **별 반복(star)을 한 번 반복하여 매칭**한 경로이고, p<sub>2</sub>는 "a" 두 개를 **별 반복(star)을 두 번 반복하여 매칭**한 경로이다. 
이 두 경로는 **과거의 매칭 과정은 다르지만, 미래는 동일하다.** 둘 다 "b"를 찾을 수 있다면 매칭 성공, 하나라도 찾지 못하면 실패이므로, **각 경로를 별도로 탐색할 필요가 없다.**

하지만 일반적인 backtracking 엔진은 **이러한 경로 병합(path merging)** 을 수행하지 않고, 대신 입력 문자열을 **모든 가능한 비어 있지 않은 하위 문자열 분해**로 열거하며 탐색한다. 
이러한 탐색은 각 경로의 끝에 도달했을 때야 "b"가 없다는 사실을 깨닫게 되며, 결과적으로 "a"의 개수에 따라 **지수 시간 복잡도**를 유발한다.

반면, **선형 엔진들은 모두 uniform-futures 속성을 활용하여 이러한 수렴 경로들을 병합**한다.

그러나 **backreference가 존재할 경우,** uniform-futures 속성은 더이상 성립하지 않는다. 
**경로의 미래는 그 경로의 과거(prefix)에 따라 달라질 수 있는데,** 이는 backreference의 매칭이 **이전에 캡처 그룹이 어떻게 매칭되었는지에 의존하기 때문**이다. 

이러한 이유로, **선형 엔진은 backreference를 지원하지 않는다.** 
또 이 논문 발표 이전까지, **lookaround 역시 선형 엔진에서 제외된 기능이었다.** 
하지만 우리는 섹션 4.3에서 **lookaround도 실제로는 선형적으로 매칭 가능함**을 보여준다.


**Bit-state backtracking(또는 memoized backtracking)** 은 가장 단순한 형태의 **선형 시간 매칭 알고리즘**으로, 
기존 backtracing 방식에 **memoization table**을 추가하는 방식이다.

이테이블은 검색 중 고려된 **정규표현식 상태(state)** 와 **입력 문자열 위치(position)** 의 모든 쌍(pair)를 기록한다.

이 메모이제이션 테이블만으로도 **uniform-futures property**를 활용하기에 충분하다. 
어떤 경로가 이전에 방문한 (state, position) 쌍에 도달하면, 그 경로는 **더 이상 탐색하지 않고 버려진다.**

이 접근법은 backtracking 엔진의 장점, 즉 **backtracking이 적은 정규표현식에서의 뛰어난 성능**은 그대로 유지하면서도, **최악의 경우를 방지할 수 있는 선형 시간 보장**을 제공한다.

그러나 이 방식은 **메모리 사용량이 O(|_r_| x |_s_|)** 으로 매우 커지는 단점이 있어, 최신 엔진에서는 **작은 정규표현식과 문자열에 대해서만 제한적으로 사용된다.**


**Thompson 시뮬레이션, PikeVM**보다 **메모리 효율적인 방식은 NFA 시뮬레이션**이며, 이는 일반적으로 **Thompson 알고리즘**으로 불린다. 
이 방법은 대부분의 선형 정규표현식 엔진에서 **일반적인 경우에 사용되는 기본 방식**이다.

이 방식은 그래프를 **너비 우선 탐색(BFS)** 하며, **같은 입력 문자열 접두(prefix)를 소비한 경로들은 동시에 고려**하고, **uniform-futures property**를 이용해 **수렴하는 경로들을 병합**한다.

이러한 NFA 시뮬레이션은 **tagged NFA**로도 확장 가능하며, 이를 통해 **캡처 그룹 지원**이 가능하다.

이 경우, 그래프와 그 탐색 알고리즘은 **통합된 바이트코드 형식**으로 변환되며, **PikeVM**이라 불리는 가상 머신이 이를 실행한다.

본 논문은 이 **NFA 시뮬레이션 및 PikeVM 알고리즘에 대한 확장을 제안한다.**


**Lazy DFA**  
마지막으로 **캡처 그룹이 없는 정규표현식의 경우**, 많은 엔진들이 **Lazy DFA 시뮬레이션**을 수행한다. 
이것은 NFA 시뮬레이션의 변형 형태로, **최악의 경우 선형 시간 복잡도를 유지하면서도 평균 성능이 더 우수하다.**

Lazy DFA는 NFA 시뮬레이션과 유사하게 동작하지만, **방문한 상태들을 리스트가 아니라 집합(set)** 으로 관리한다. 
캡처 그룹이 없을 경우, state 순서가 중요하지 않기 때문에 set으로 처리가 가능하다.

이 방식은 전통적인 DFA의 선행구성(ahead-of-time determiniztion)과 실행을 **lazy하게 병합한 것**으로 볼 수 있다. 
즉, 입력 문자열을 처리해 나가며, **전통적인 DFA가 미리 구성했다면 방문했을 상태들을 그때그때 동적으로 생성하는 방식**이다. 
전통적인 DFA 구성은 **O(2^|_r_|)** 의 시간 복잡도를 갖는 반면, Lazy DFA는 최대 **|_s_|번의 전이**만 수행하며, 각 전이는 **이웃 상태 계산에 O(|_r_|)** 복잡도를 가진다.

---
### Notes

* **NFA (Nondeterministic Finite Automaton)**
  * 여러 경로를 동시에 허용하는 모델
  * ε-transition: 입력 문자를 소비하지 않고 상태를 바꾸는 전이
  * label transition: 특정 문자를 읽고 이동하는 전이
* **Thompson Construction**
  * 전통적인 정규표현식을 **재귀적으로 작은 단위로 나누어** 이에 대응하는 NFA fragment를 만들고, 이들을 연결하여 전체 NFA를 만드는 방법
  * 주요 패턴
    * a: a 하나에 대해 직접 이동
    * e<sub>1</sub>e<sub>2</sub>: 두 표현식을 순서대로 연결 (concatenation)
    * e<sub>1</sub>|e<sub>2</sub>: 두 표현식 중 하나를 선택 (alternation)
    * e*: 반복 (Kleene star)
* **복잡도 관점**
  * 정규표현식 크기 |r|에 대해 NFA 구성은 O(|r|) 시간
  * 생성된 NFA의 상태 수와 전이 수 역시 O(|r|)

* **Thompson NFA**는 순수하게 문자열 수용 여부만 검사하는 구조였다.
* **캡처 그룹**을 다루기 위해, NFA를 다음 두 가지 방식으로 확장한다.
  1. **Edge Priority 추가**
     * 하나의 상태에서 여러 전이가 가능한 경우
     * 어떤 전이를 먼저 시도할지 **우선순위(priority)** 를 설정
     * 그림에서는 **점선**으로 표시
  2. **Effectful Nodes 추가**
     * 캡처 그룹의 **시작과 끝을 기록**하는 특수한 노드를 삽입
     * 예를 들어, **#1: entry 노드**를 통과하면 "여기서 첫 번째 캡처 그룹 시작"을 의미하고, 이후 **exit 노드**를 통해 종료 위치도 기록
* **Tagged NFA [Laurikari 2000]**
  * 표준 NFA에 "위치 추적"과 "우선순위" 기능을 추가한 변형
  * 캡처 그룹을 지원하기 위해 널리 사용됨 

* **Backtracking 기반 매칭**
  * NFA의 가능한 경로를 **우선순위 순서로 탐색**하여, **처음으로 성공적인 경로**를 찾는 방식
  * 경로 수가 많아질 경우 단순한 전통적 정규표현식에서도 **최악의 경우 지수 시간 복잡도**를 나타냄
* **Backreference의 영향**
  * **Backreference가 포함되면, 매칭 문제는 NP-hard**가 되어 입력 문자열 크기와 정규표현식 크기 모두에 대해 Polynomial Time 내 해결이 어렵게 됨
* **선형 시간 매칭 가능 조건**
  * **Backreference를 제거**
  * **Lookaround 등 일부 복잡한 기능을 제외**
  * 특정 인사이트를 통해 **입력 문자열과 정규표현식 길이에 대해 선형 시간** 매칭 가능


* **Uniform-futures property**  
  어떤 오토마타 경로(prefix)가 현재 **정규표현식의 상태(state)와 입력 문자열 위치(position)** 만 같다면, 그 이후의 확장 경로는 **과거에 어떤 경로로 도달했는지와 관계없이 동일한 결과**를 가지는 성질
  * 즉, **경로의 미래(future)** 는 현재 상태와 입력 위치에만 의존함.
  * 이를 만족할 시, **동일 상태/위치에서 시작된 경로들을 병합하는 path merging** 을 수행할 수 있어 **선형 시간 매칭이 가능함**
  * 캡처 그룹이 포함된 경우에도, **우선순위** 관계가 유지됨.
* **Path merging**  
  서로 다른 경로(precix)들이 같은 상태와 위치에 도달한 경우, **미래가 같다면 중복 탐색을 피하고 하나의 경로만 유지**하는 최적화 방법.  
  선형 엔진에서 필수적이며, backtracking 엔진에서는 수행하지 않음.
* **Backtracking의 한계**  
  * 모든 가능한 경로를 분해하고 탐색하기 때문에 **지수 시간 복잡도를 가짐**
  * 예: /(a+)*/b + "aaa" → "a" 분해 방식 모두 시도 후 "b" 없음 판별 → 최악의 경우 발생
* **Backreference와 Unifrom-futures 불일치**  
  * backreference는 **이전 캡처 그룹의 값**에 따라 결과가 달라지므로, **경로의 과거(prefix)** 에 따라 **미래 결과가 달라질 수 있음.**
  * **⇒ uniform-futures property 불충족 → 경로 병합 불가 → 선형 매칭 불가능**
  * 따라서 **모든 선형 엔진은 backreference를 지원하지 않음**


* **Bit-state backtracking = Backtracing + Memoization**  
  (state, position) 쌍이 이미 방문되었는지 기록(Memoization) → 이미 방문한 조합에 대한 중복 탐색 X(Uniform-futres를 활용) **→ 선형 시간 보장**
  * 장점
    * 빠른 경로를 빠르게 찾는 기존 backtracking의 장점을 유지
    * worst-case에서의 지수 시간 탐색 방지 **→ 선형화**
  * 단점
    * O(|_r_| x |_s_|) 크기의 메모리 테이블 필요
    * 실질적으로는 **작은 정규표현식, 짧은 문자열**에 한정해서 사용 가능
    * Google 등 실제 상용 엔진에서도 **제한적으로만 사용됨**


* NFA 시뮬레이션 (Thompson Simulation)  
  * 정규표현식을 Thompson 구성으로 만든 NFA를 실행
  * 상태 집합을 유지하며, **너비 우선 탐색** 방식으로 실행
  * 같은 입력 접두(prefix)를 소비한 경로들을 **동시에 병렬 처리 → uniform-futures property에 따라 병합 가능**
  * **메모리 효율이 bit-state backtracking보다 우수함**
* **Tagged NFA 확장**
  * **캡처 그룹 위치 추적**을 위해 NFA에 **태그 부착**
  * 이를 처리하기 위해 단순 상태 전이뿐 아니라 **부가 정보 기록 노드를 필요로 함.**
* **PikeVM**
  * Tagged NFA 및 실행 알고리즘을 **하나의 바이트코드로 컴파일**
  * 이를 **전용 가상 머신인 PikeVM**에서 해석 및 실행함 → 더 정형화된 처리 모델, **캡처 그룹 등 고급 기능 지원 가능**


* **Lazy DFA**  
  **캡처 그룹이 없는 경우에 사용**되는 고성능 시뮬레이션 기법
  * 기존 DFA처럼 상태를 미리 모두 생성하지 않고, **실행 도중에 필요한 상태만 동적으로 구성**하는 방식
* **NFA 시뮬레이션과 차이점**
  * NFA 시뮬레이션: 상태 집합을 리스트로 저장 → 순서 정보 유지
  * Lazy DFA: 상태 집합을 **집합(set)** 으로 저장 → 캡처 그룹 없을 때 순서 무시 가능
  * 캡처 그룹이 없다면, 상태 순서가 무관하므로 Lazy DFA는 **공간 절약 + 성능 개선 측면에서 매우 유리**

| 항목                           | 설명                                                                     | 
| ---------------------------- |------------------------------------------------------------------------| 
| **전통 정규표현식**                 | NFA로 표현 가능. Thompson 방식으로 구성 시 O(r) 시간/공간.                             | 
| **Tagged NFA**               | capture group을 처리하기 위해 edge priority와 effectful node 추가.               |
| **Backtracking 엔진**          | 모든 경로 열거, 첫 accept 경로 반환. 전통 표현식만 써도 지수 시간 가능.                         |
| **Uniform-futures property** | 현재 상태+위치만 같으면 미래 경로 동일 → path merging 가능. 선형 알고리즘의 핵심 기반.              |
| **Bit-state backtracking**   | backtracking + memoization. 선형 시간 가능하지만 O(r x s) 메모리 비용.               |
| **NFA 시뮬레이션 (Thompson 기반)**  | BFS 기반. 평균 성능 좋고 메모리 효율도 bit-state보다 우수. PikeVM으로 확장 가능.               | 
| **Lazy DFA**                 | capture group이 없을 때 사용. 상태를 미리 구성하지 않고 필요할 때 동적으로 생성. 평균 성능 우수, 최악도 선형.| 


---
## **III. Techinical Background**

본 섹션에서는 핵심 주제, **JavaScript 정규표현식에 맞게 NFA 시뮬레이션을 적응시키는 방법**으로 이동한다. 
이 섹션에서는 먼저 **JavaScript 정규표현식 언어와 그 의미론(Semantics)의 특수성**을 소개하고, 이후 **NFA 시뮬레이션을 상세히 설명하여, 4장에서 제시될 주요 기여에 대한 기반을 마련한다.**


### **3.1. JavaScript Regex Syntax**  
본 논문은 **그림 3에 제시된 JavaScript 정규표현식의 부분집합**을 대상으로 한다. 
**Greedy 연산자는** 때때로 **eager**라고도 불리며, **Lazy 연산자는** **nongreedy**라고도 한다.

우리의 모든 알고리즘은 다음과 같은 **선형 시간 보장을 갖는 추가 기능들**도 지원한다. 
* **앵커(anchor)** (^, $)
* **문자 클래스(character classes) ([a-z], \d, \w 등)**
* 또는 **주변 문자만을 참조하는 임의의 조건(predicate) 등**

**카운트 반복(counted repetitions)** 또한 지원되며, 이는 하위 표현식을 반복함으로써 구현된다(이 방식은 **최신 선형 정규표현식 엔진들과 동일한 방식이다**).

다만, 이 경우 **카운트 값이 커질수록 정규표현식의 크기와 매칭 시간 복잡도도 함께 증가**하게 된다.

**표기법(Notation)**  
정규표현식을 보다 읽기 쉽게 만들기 위해, 우리는 **JavaScript에서 일반적으로 사용하는 (?:r) 대신 r 형식을 noncapturing group**으로 사용한다. 
이러한 **noncapturing group은 파싱의 모호성을 줄이기 위한 주석(annotation)** 일 뿐이며, **실제로 캡처 그룹을 생성하지는 않는다.**

또한 **빈 정규표현식(empty regex)** 을 나타낼 때는 아무것도 쓰지 않는 대신 **기호 epsilon**을 사용한다. 
예로, /a|𝜖/는 실제로 /a|/와 같은 의미이다.
논문에서는 때떄로 **정규표현식의 캡처 그룹에 번호를 붙여 표기한다.** 예로, /a(b)(c)/ → /a(b)#1(c)#2/가 있다. 
JavaScript에서는 **각 캡처 그룹은 (이름 있는 것 포함해서) 고유한 식별자**를 가져야 한다.

**Lookaround**에 대해서도 **각각 고유한 식별자(identifier)** 를 부여한다. 
이 식별자는 **AST의 preorder 순회(preorder traversal of the Abstract Syntax Tree)** 에 따라 **정수값으로 부여**되며, 
**Lookaround l≶𝑖 가 다른 Lookaround l≶𝑗 를 포함하는 경우에는 항상 𝑖 < 𝑗가 된다.**

예를 들어, 정규표현식 /(?=a(?<=a))a/는 다음과 같이 주석된다. /(?=≶1a(?<=≶2a))a/

논문에서는 **정규표현식 r 내의 lookaround 개수를 ℓ(r)** 로 표기한다.
예: ℓ(/(?=a(?<=a))a/) = 2


### **3.2. JavaScript Regex Semantics Peculiarities**  
대부분의 현대 정규표현식 언어는 여러 비전통적인 기능들을 공유하고 있지만, 
여러 **차이점을 가지고 있다.** 
이 차이점들은 거의 문서화되지 않았지만, 정규표현식 매칭의 **Semantics**나 **시간 복잡도**에 상당한 영향을 미칠 수 있다. 
이 섹션에서는 **JavaScript 정규표현식 언어의 몇 가지 미묘하고 중요한 특성**에 대해 다루며, 
이것들이 **다른 정규표현식 언어들과 구별되는 점**을 설명한다.

**Priority**  
JavaScript의 **backtracking 의미론(semantics)** 은 주어진 **우선순위 순서**로 경로를 탐색한다. 
**Alternation(선택)** 에서는 **왼쪽 분기가 오른쪽 분기보다 우선순위가 높다.** 
**Greedy quantifier** 에서는 **가능한 많은 반복을 우선시**하는 반면, 
**Lazy quntifier** 는 **최소한의 반복을 우선시한다.**
JavaScript 정규표현식은 **앵커가 없기 때문에,** 매칭이 **입력 문자열의 어디에서든 시작할 수 있다.** 
**입력 문자열에서 가장 먼저 시작하는 매칭이 우선순위가 높다.** 
실제로, 엔진은 **그 매칭을 찾기 위해 정규표현식에 .*?** 를 접두어로 추가한다.

**Capturing Lookarounds**  
JavaScript에서 **lookaround**는 단순한 **assertion** 이상이다. 
**Lookahead와 lookbehind는 캡처그룹을 정의**할 수 있으며, 이는 엔진에서 반환해야 하는 값이 된다. 
예를 들어, /((?=(c))#1)/를 "c"에 적용하면, **캡처 그룹 #1**이 "c"로 설정된다는 결과를 반환한다.  
하지만 **대부분의 현대 정규표현식 언어에서처럼, negative lookarounds는 캡처 그룹을 정의할 수 없다.**

**Unbounded Lookarounds**  
일부 언어들(Perl, Python, Java)은 **고정 너비(fixed-width) lookaround만 허용**한다. 
이는 **lookahead와 lookbehind 내에 포함된 정규표현식 패턴이** *, +와 같은 **unbounded quantifiers를 포함해서는 안 된다는 의미**이다. 
하지만 **JavaScript에서는 이런 제한이 없으며,** /(\?=a*)/와 같은 정규표현식이 유효한 정규표현식으로 간주된다.  
**고정 너비 lookaround**는 **앵커**처럼 구현이 어렵지 않지만, **제한 없는 lookaround는 더 표현력 있고 복잡한다.**

**Capture Reset**  
수량자에 들어갈 때, 해당 수량자 내에서 정의된 캡처 그룹의 값은 **undefined**로 리셋된다. 
예를 들어, 문자열 "ab"에 대해 정규표현식 /((a)#2|(b)#3)#1*/을 매칭하면, 
그룹 #2는 **undefined**로 설정된 매칭 결과가 반환된다. 
첫 번째 * 반복에서, #2는 **범위 0-1**로 설정되어 문자열의 첫 번째 문자를 매칭한다. 
두 번째 * 반복을 실행할 때, #2는 다시 **undefined**로 리셋되며, 
그룹 #3은 **범위 1-2**로 설정되어 문자 "b"를 매칭한다.  
이 속성은 **JavaScript 정규표현식 언어에만 특정한 특징**이다. 
우리는 이 속성이 **선형 시간**으로 구현하는 데 어려움이 있지만(섹션 4.2 참조), 
**선형 시간으로 다른 기능들을 구현하는 데 도움을 준다(섹션 4.5.3 및 4.3 참조).**

**Nullable Quantifiers**  
수량자는 **필수 반복(iterations)** 과 **선택적 반복(optional iterations)** 을 모두 가질 수 있다. 
예를 들어, **플러스(+)는 하나의 필수 반복**이 있으며, 그 뒤에는 **아무 개수만큼의 선택적 반복**이 가능하다. 
**별(*)은 필수 반복이 없고, 아무 개수만큼의 선택적 반복**만 가능하다.  
JavaScript에서, **수량자의 선택적 반복은 빈 문자열**과 일치할 수 없다. 
이는 예를 들어 **nullable star**를 매칭할 때, **백트래킹 구현이 무한 루프에 빠지는 것을 방지**한다. 
이와 같은 **nullable quantifier에 대한 의미론은 JavaScript에 특화된 특성**이다. 
다른 정규표현식 언어들은 일반적으로 **nullable quantifier에 대해 다른 의미론**을 가지고 있으며, 이에 대해서는 섹션 4.1에서 다룬다.


### **3.3. NFA Simulation Engines**  
NFA 시뮬레이션 알고리즘은 **determinization의 지수 시간 비용**을 피하기 위해 널리 사용되는 방법이다.  
이 알고리즘은 **V8Linear, RE2, Rust, Go**에서 사용된다. 
태그된 NFA는 일반적으로 **바이트코드**로 표현된다. 
이 바이트코드는 **그림 4**에 나타난 바이트코드 명령어 배열에 해당하며, 각 명령어는 **label**과 연결된다.  
**시뮬레이션 엔진(알고리즘 1에 표시된 바와 같이)** 은 **우선순위에 따라 정렬된 스레드 목록**인 active를 유지한다(이는 LIFO 리스트이다). 
각 스레드는 **프로그램 카운터(pc)** 와 **레지스터 집합(regs)** 을 포함한다. 
스레드는 **동일한 문자열 위치(i)에서 동기화된 NFA의 미완성 경로**를 나타낸다. 
처음에는 active에 **pc 0인 단일 스레드**가 포함된다. 
알고리즘은 문자열을 한 문자씩 처리한다(반복문). 
다음 문자열 위치에 대한 스레드 목록을 계산하려면, **우선순위가 가장 높은 스레드**부터 시작하여 NFA의 전이를 따른다.  
스레드가 **다음 문자에 해당하는 Consume 명령어**에 도달하면, 해당 스레드는 next에 추가된다. 
새로운 스레드는 **Fork 명령어**로 생성될 수 있으며, 스레드가 **Accept 명령어**에 도달하면, **현재까지 찾은 가장 좋은 매칭으로 저장**된다. 
우선순위가 낮은 스레드는 버려지지만, 알고리즘은 **우선순위가 높은 스레드**로 계속 실행된다. 
또한 알고리즘은 **이미 실행된 바이트코드 명령어를 나타내는 processed 배열을 유지한다.** 
이 배열에 이미 해당 명령어가 실행된 스레드가 도달하면, **그 쓰레드는 active.pop()** 으로 삭제된다.(섹션 2의 **Unifrom-futures 속성을 사용**) 
이 배열 덕분에 각 바이트코드 명령어는 **각 문자열 위치에 대해 최대 한 번만 실행**된다.  
Example  
정규표현식 / (a|.)b / (그림2)와 문자열 "ab"를 고려해보면, 처음에 **active는 pc 0**인 단일 스레드를 포함한다. 
첫 번째 문자를 처리한 후, **active 리스트에는 pc 3에 있는 스레드와 pc 5에 있는 스레드가 포함된다.** 
두 번째 반복에서 두 번째 스레드는 **pc 5**에서 명령어를 먼저 실행한 첫 번째 스레드에 의해 제거된다. 
마지막 문자를 읽은 후, **단일 스레드가 Accept 명령어어에 도달한다.** 
이 스레드의 레지스터 값을 사용하여, **캡처 그룹 #1은 0과 1사이의 인덱스로 구분된 부분 문자열을 포함하고 있음을 알 수 있다.** 
이는 **첫 번째 문자 "a"** 를 나타낸다.  
문자열 "ac"에서는, 시뮬레이션 엔진이 **상태 6에 있는 스레드**가 두 번째 문자를 처리할 수 있는지 한 번만 확인하고, 즉시 **매칭되지 않음**을 결론짓는다. 
반면, **백트래킹 구현**에서는 **첫 번째 문자를 소비한 각 경로에 대해 두 번 확인**하게 된다.  
Complexity  
정규표현식 _r_ 에 대해 생성되는 **바이트코드의 크기와 epsilon 전이의 수는 정규표현식 크기 O(|_r_|)** 에 비례하여 선형적으로 증가한다. 
그 후, 각 문자열 위치마다 시뮬레이션은 **각 바이트코드 명령어를 최대 한 번만 실행, 각 전이도 최대 한 번만 따라간다.**

따라서, 정규표현식 _r_ 과 문자열 _s_ 에 대해 **최악의 경우 O(|_r_| x |_s_|)** 개의 바이트코드 명령어가 실행된다. 
이 명령어들 중 **Fork를 제외한 모든 명령어는 O(1)** 시간 복잡도로 쉽게 구현 가능하다. 
**Fork 명령어와 공간 복잡도에 대해서는 섹션 4.6에서 추가로 논의된다.**

---
### Notes

Background
* **Regex vs Regexes**:  
  전통적 정규표현식 (regex) 은 정규 언어와 동치인 표현력만을 가지며 DFA/NFA 기반의 결정적 동작이 가능한 반면, 
  현대 정규표현식 (regexes) 은 lookaround, backreference, capture group 등의 기능으로 인해 정규 언어를 넘어서는 표현력과 복잡도를 가진다.
* **NFA 시뮬레이션**:  
  DFA determinization의 지수 시간 복잡도를 회피하기 위한 대안으로, 여러 상태를 동시에 추적하면서 선형 시간에 가까운 실행을 가능케 하는 알고리즘 패턴. 
  특히 V8Linear, RE2 등 최신 선형 정규표현식 엔진에 적용됨.
* **바이트코드 (bytecode)**:  
  NFA 시뮬레이션 구현 시, NFA의 각 상태와 전이를 컴팩트한 명령어 배열로 구성하여 정규표현식을 실행 가능한 형태로 변환한 것.
  이를 통해 PikeVM 등에서 효율적으로 정규표현식 매칭 가능.
  Uniform-futures property (섹션 2):
  입력 문자열과 정규표현식의 현재 상태가 같다면 경로의 미래도 같다는 성질. 이를 이용해 중복 경로를 병합하여 선형 시간 유지.
  단, backreference나 lookaround 존재 시 이 성질이 깨질 수 있음.


**JavaScript regex의 구문적, 의미적 특수성**:  
* 표현식 내부에 unbounded lookaround 사용 가능, lookaround 내부 캡처 그룹 허용, nullable quantifier는 empty string과 매치 불가 등의 특징은 다른 언어와 의미론적으로 다름.
* 특히 capture reset은 반복마다 내부 그룹 값이 undefined로 초기화 됨 → 이후 **lookaround를 선형적으로 처리할 수 있게 해주는 핵심!**

**Regex 표현식 → Tagged NFA → Bytecode → PikeVM** 플로우:
* 표현식은 Tagged NFA로 변환되고, 이는 Bytecode 형태로 컴파일되어 PikeVM에서 실행됨
* 각 명령어는 레이블과 연겨로디어 있고, 실행은 LIFO 방식으로 스레드를 관리하며 우선순위 순으로 경로를 따라간다.

**Simulation 알고리즘의 구조와 최적화**:
* active 스레드 리스트에 현재 위치의 후보 상태들을 쌓고, processed 배열을 사용하여 중복 실행 방지 → **O(|_r_| x |_s_|)** 보장
* 각 명령어는 O(1)으로 실행되며, **Fork 명령만 예외**, Fork의 시간/공간 복잡도는 4.6에서 이어질 예정
* 실제 매칭 예시에서처럼, 시뮬레이션은 backtracking에 비해 **중복 경로 평가를 회피하여 성능 향상**

**JavaScript의 의미론은 엔진 구현에 직접적인 영향을 미친다**:
* ECMA-262 표준이 정의한 우선순위 규칙, 캡처 리셋, lookaround 캡처 등은 **정규표현식 엔진 구현 복잡도를 증가**
* 하지만 본 논문에서는 이러한 semantics 특성을 **선형 알고리즘 구현의 기회로 전환**하려는 시도를 보임.

---

## **IV. Matching JavaScript Regexes With Linear-time Guarantees**

본 섹션에서는 JavaScript 정규표현식 언어의 다양한 기능들을 **선형 시간 복잡도**로 매칭하기 위한 **여섯 가지 알고리즘**을 제시한다. 
먼저 4.1절에서 JavaScript의 의미론 중 하나인 **Nullable Quantifier** 특성이 전통적인 NFA 시뮬레이션 엔진과 **호환되지 않음을 보여주고, 이에 대한 선형 시간 확장 기법을 제안한다.** 
이어서 4.2절에서 JavaScript 고유의 **Capture Reset 의미론을 선형 시간에 구현할 수 있는 알고리즘을 제시**하는데, 이는 기존 구현에서 **정규표현식 크기 제곱 수준의 복잡도를 야기**하던 문제였다.

이후에는 지금까지 **선형 엔진에서 지원되지 않았던 JavaScript 기능들**을 다룬다. 
4.3절에서는 **제한 없는(unrestricted) lookaround**를 위한 알고리즘을 제시한다. 
4.5절에서는 **nonnullable, greedy한 JavaScript plus** 연산자의 **선형 매칭 알고리즘**을 제시한다. 
마지막 4.6절에서는 **NFA 시뮬레이션에서 캡처 그룹 레지스터를 구현할 때 발생하는 시간-공간 복잡도 사이의 새로운 trade-off**를 소개한다. 
우리 알고리즘은 **모두 조합 가능한 구조(composable)** 한 구조를 가지며, 이 모든 기법을 종합했을 때, 우리는 **backreference가 없는 JavaScript 정규표현식의 대부분이 O(|_r_| x |_s_|) 최악 시간 복잡도 내에 매칭 가능함**을 보인다.


### **4.1. Matching JavaScript Nullable Quantifiers in a Linear Engine**  
여러 정규표현식 언어 중에서, **JavaScript nullable 수량자(예: *, +)에 대해 고유한 의미론**을 가진다. 
**2장에서 소개된 기법들과 uniform-futures 속성은 이러한 JavaScript 의미론을 따르지 않는다.** 
그 결과, NFA 시뮬레이션을 사용하는 **V8Linear 엔진은 종종 ECMA 명세와 다른 결과를 반환하는 오류**를 내기도 했다. 
하지만 우리는 **이러한 알고리즘들을 비대칭 복잡도 (= 시간복잡도 변화 없이) 유지하면서 의미론을 반영할 수 있는 새로운 적응 기법**을 제안한다.

**NFA 시뮬레이션 알고리즘은 문자열에서 아무 문자도 소비하지 않고 동일한 정규표현식 상태를 두 번 방문할 수 없다(알고리즘 1의 processed 배열).** 
그러나 **JavaScript에서는 해당 상태가 수량자의 시작 지점을 나타내지 않는 한,** 문자를 소비하지 않고 동일한 상태를 두 번 방문하는 것이 **허용**된다. 
예를 들어 정규표현식 / a|𝜖 𝜖|b */를 문자열 "ab"에 매칭하는 경우를 생각해보면(Figure 5), 일반적인 NFA 시뮬레이션에서 가장 우선순위가 높은 결과는 "a"만을 단일 star 반복에서 매칭하는 것이다. 
하지만 두 번째 star 반복을 시도하는 것은 유효하지 않은데, 이는 문자열에서 아무 문자도 소비하지 않은 채 **동일한 정규표현식 상태 (_s<sub>_3_</sub>_)** 를 다시 방문하기 때문이다.  
**JavaScript에서는 전체 문자열 "ab"를 두 번의 star 반복을 통해 매칭하는 것이 올바른 결과이다.** 
첫 번째 반복에서는, **첫 번째 alternation에서 "a"를, 두 번째 alternation에서는 빈 문자열 𝜖을 매칭**한다. 
두 번째 반복에서는, **𝜖을 먼저 매칭한 뒤, "b"를 매칭한다.** 
이 두 번의 반복 모두 **문자열의 비어 있지 않은 부분**을 매칭한 것이다.  
JavaScript에서는 **경로 접두사(path prefix)의 미래는 단순히 현재 문자열 위치나 정규표현식 상태에만 의존하지 않는다.** 
대신, **현재 반복자(quantifier) 내부에서 이미 어떤 문자열을 소비했는지도 함께 고려되어야 한다.** 
Figure 5에서 상태 _s_<sub>_3_</sub>에서 다시 _s_<sub>_3_</sub>로 전이 가능한 것은, 현재 실행이 **이전에 _s_<sub>_2_</sub>에서 "a"를 소비한 경우에 한해서이다.**


**JavaScript의 의미론에 맞게 NFA 시뮬레이션 알고리즘을 조정하기 위해**, 우리는 아래 사항을 관찰한다.:  
하나의 정규표현식 state와 입력 문자열 postion이 주어졌을 때, **"현재 경로가 문자를 소비하지 않고 수량자(quantifier)를 빠져나갈 수 있는지 여부"에 따라 최대 두 가지 방식이 존재**한다. 
이 두 동작 방식을 구분하기 위해, 우리는 **정규표현식의 상태를 복제**한다(Figure 6).  
Figure 6 왼쪽의 **서브 오토마타는 상태 _s_<sub>_i_</sub>들을 포함하는데,** 이 상태들은 **모든 상위 수량자에서 이미 문자를 소비했기 때문에,** 문자를 소비하지 않고도 수량자에서 벗어날 수 있다. 
반면, 오른쪽의 상태 _t_<sub>_i_</sub>들은 **현재 가장 안쪽(innermost)** 수량자에서 문자를 소비하지 않은 상태이기 때문에, 문자를 소비하지 않고 수량자에서 벗어 나는 것이 **허용되지 않아야 한다.**

즉, **수량자 반복이 막 시작된 스레드는 반복을 종료해서는 안 된다.** 
따라서 우리는 **각 수량자의 시작 지점에 BeginLoop 바이트코드 명령어**를 삽입하여, 실행 흐름을 **오른쪽 서브 오토마타로 전환**한다.  
이후 문자를 하나라도 소비하는 순간, 전이는 항상 **왼쪽 오토마타로 돌아가도록 설계**된다. 
이렇게 되면 비록 스레드가 여러 개의 중첨된 수량자에 있다 하더라도, 모두에서 **문자를 소비했기 때문에 반복을 종료할 자격이 생기게 된다.**  
수량자의 끝 지점에서는 EndLoop 명령어를 삽입한다. 
왼쪽 오토마타에서는 이것이 일반적인 Jump처럼 동작하지만, 오른쪽 오토마타에서는 **스레드를 차단(blocking)하는 상태**로 작동한다.

Correctness  
정규표현식의 수량자는 **항상 괄호 구조가 올바르게 중첨(well-parenthesized)** 되어 있으므로, 어떤 스레드가 **가장 안쪽 수량자는 빠져나갈 수 있지만, 바깥쪽 수량자는 빠져나갈 수 없는** 경우는 발생하지 않는다. 
그 겨라, 수량자가 **아무리 중첩되어 있어도, 원래 오토마타를 두 개 복제한 구조만으로** JavaScript 수량자 의미론의 모든 동작을 정확히 포착할 수 있다.

우리는 이러한 의미론적 불일치를 V8Linear 팀에 보고했고, **해결책을 구현하여 V8Linear에 병합**했다. 
실제로 NFA 시뮬레이션을 구현할 때는, **바이트코드를 실제로 복제할 필요는 없다.** 
대신, 각 **스레드에 boolean 값을 추가하여 해당 스레드가 어느 오토마타(왼쪽/오른쪽)에 속해 있는지를 표시**한다. 
**BeginLoop, EndLoop, Consume 명령어**는 이 boolean을 **읽거나 수정**하게 된다.  
Figure 7에서 보여지듯, 이 boolean은 left라는 이름을 가진다. 
만약 **수량자 내부의 정규표현식이 nullable하지 않다면(빈 문자열과 매치될 수 없다면), BeginLoop와 EndLoop 명령어를 삽입할 필요가 없다.** 
이러한 **nullable 여부를 판별하는 간단한 분석 방법**은 4.5절에서 설명된다.  
우리는 이 해결책을 NFA 시뮬레이션 기반으로 설명했지만, **bit-state backtracking이나 Lazy DFA에도 동일하게 적용 가능**하다. 
또한 이 방법은 **counted repetition(카운트 기반 반복자)** 에도 일반화된다. 
예를 들어, 정규표현식 /a|𝜖 𝜖|b{0,7}/에서는, 선택적 반복은 빈 문자열과 매치되어서는 안 된다. 
이 경우, **각 optional repetition의 바이트코드를 BeginLoop와 EndLoop로 감싸기만 하면 충분**하다.



### **4.2. Linear Matching of the Capture Reset Property**  
3.2절에서 소개한 **Capture Reset 속성은 JavaScript 정규표현식 언어에만 고유하게 존재하는 특성**이다.
이 절에서는 **V8Linear에서 사용되었던 기존 해결책이 정규표현식의 크기 (|_r_|)에 대해 이차 시간 복잡도(quadratic complexity)** 를 가지는 이유를 설명하고,
이 **Capture Reset 속성을 처리하기 위한 새로운 선형 시간 알고리즘을 제안**한다.

**기존의 이차 시간 알고리즘:**  
V8Linear에서 사용된 **직관적인 해결 방법**은 새로운 바이트코드 명령어인 ```ClearReg reg``` 를 정의하는 방식이다.
이 명령어는 **해당 캡처 그룹의 레지스터 값을 제거하여 undefined로 초기화**한다.
이러한 ```ClearReg``` 명령어는, **수량자 내부에 정의된 각 캡처 그룹마다, 해당 수량자의 시작 부분에 삽입**된다.
예를 들어, **Figure 8은 정규표현식  / (a)|b *|c */에 대해 생성된 바이트코드 명령어**를 보여준다.
여기에서는 4.1절에서 다룬 **BeginLoop와 EndLoop 명령어를 생략**하여, 두 속성을 **독립적으로 설명**한다.
**캡처 그룹이 여러 수량자 안에 중첩되어 정의된 경우, 각 수량자마다 시작 지점에 해당 캡처 그룹의 레지스터를 초기화해야 한다.**
예를 들어, 정규표현식 / (a)|b *|c */를 "ac"에 매칭하는 경우,
**외부 star 반복에 두 번째로 진입할 때 캡처 그룹을 초기화하기 위해 첫 번째 ```ClearReg``` 명령어가 필요**하다.
같은 정규표현식을 "ab"에 매칭하는 경우에는, **내부 star 반복에 두 번째로 진입할 때 해당 값을 초기화하기 위해 두 번째 ```ClearReg``` 명령어가 필요**하다.
결과적으로, **각 캡처 그룹은 정규표현식 AST 상에서 자신을 포함하는 수량자의 수만큼 ```ClearReg``` 명령어를 필요로 하게 된다.**
다음과 같은 정규표현식 계열을 생각해보면:
_r_<sub>_0_</sub> = /./, _r_<sub>_n+1_</sub> = /(_r_<sub>_n_</sub>) */.
이 경우, 정규표현식의 **크기 |_r_<sub>_n_</sub>|는 O(n)** 으로 선형적으로 증가하지만, 그에 대응하는 **바이트코드의 크기는 O(n^2)** 로 이차적으로 증가하게 된다.

본 논문에서는 **NFA 시뮬레이션을 기반으로 Capture Reset 속성을 정규표현식 크기(|r|)에 대해 선형 시간**으로 처리하는 **제안된 선형 시간 알고리즘**을 제시한다.
핵심 아이디어는 다음과 같다. **바이트코드 실행 도중에 모든 스레드에서 캡처 그룹 값을 초기화(clear)하지 않고,**
대신 **최종 매칭이 발견된 후, 오직 "winning thread"에 대해서만 필요한 경우에 값을 제거**한다.
예를 들어, /(a)|b*|c*/ 정규표현식에서 매칭이 성공했을 때 어떤 캡처 그룹 값이 존재한다면, 이 값을 초기화하고 싶은 경우는 딱 두 가지다.
1. 캡처 그룹이 설정된 이후에 **내부 star 반복자**가 다시 시작된 경우
2. **외부 star 반복자**가 다시 시작되었을 경우

**각 수량자(quantifier)와 캡처 그룹이 마지막으로 진입한 시점**을 알고 있다면, 이를 기반으로 캡처 값을 유지하거나 무효화할 수 있다.
**즉, 해당 캡처 값이 두 수량자 모두 마지막으로 진입한 시점 이후에 설정된 것이라면 유요하다**고 본다.
이 **시점(time)**의 개념을 정의하기 위해, 우리는 **NFA 시뮬레이션 엔진에 "global clock"**을 도입한다.
이는 **정수값으로 시작하여, 바이트코드 명령어가 실행될 때마다 증가**한다.
Figure 10은 **Algorithm 1을 확장한 모습**을 보여주며, 여기서 ```clk```은 global clock을 의미한다.
각 스레드는 **캡처 그룹과 수량자마다 클락 값을 저장하는 새로운 레지스터 집합**을 갖는다.
* **gclocks**: 각 캡처 그룹에 대한 시간 저장
* **qclocks**: 각 수량자에 대한 시간 저장

캡처 그룹에 진입할 때 발생하는 **SegReg 명령어가 실행될 때마다,** 해당 스레드는 **현재 문자열 위치와 현재 클락 값을 레지스터에 저장**한다.
각 수량자의 본문 시작 부분에는 새로운 **SetQuant q명령어**가 추가되며, 이 명령어는 **현재 클락 값을 해당 수량자(q)에 대한 레지스터에 저장**한다.
그 결과, **수량자에 해당하는 바이트코드의 크기는 일정하게 유지,** 해당 수량자 내부에 **몇 개의 캡처 그룹이 포함되어 있는지에 따라 복잡도가 증가하지 않는다.**
이 방법은 각 스레드 당 **더 많은 레지스터가 필요**하지만, **캡처 그룹 수와 수량자 수는 정규표현식 크기 |_r_|에 비례하여 제한되므로,** 전체 메모리 사용량은 여전히 **선형적으로 증가**한다.

**매칭이 완료된 후 캡처 그룹을 필터링하는 작업은, 정규표현식 AST를 한 번 순회하는 방식으로 O(|_r_|)** 의 시간 복잡도 내에서 수행할 수 있다.  
예를 들어 정규표현식 / (a)*| (b)|(c) * */ 와 문자열 "abc"를 고려해보면,
**Figure 9는 이 정규표현식에 대한 단순화된 AST를 보여주며, winning thread에서 각 캡처 그룹과 수량자가 가진 최종 clock 값**을 표시하고 있다.  
본 논문에서는 AST의 **루트 노드부터 시작하여, 그 자식 노드들과 clock 값을 비교**한다.
**내부의 왼쪽 star 수량자**가 **외부 star보다 clock값이 작다면,** 이는 해당 반복이 **최종 반복 이전에 수행되었음을 의미하므로, 그 내부의 모든 캡처 그룹은 제거(clear)된다.**  
이후 우리는 **오른쪽 star 수량자에 대해 재귀적으로 같은 비교를 수행**한다.
그 자식 중 하나인 그룹 (b)는 **clock 값이 부모 star보다 작으므로,** 이 역시 **마지막 반복(iteration)에서 정의되지 않았다고 판단되어 무효화(clear)** 된다.
마지막으로 그룹 (c)는 부모 star보다 **더 나중에 정의되었기 때문에 유지(keep)** 된다.


정당성(Correctness)  
우리가 제안한 **새로운 NFA 구성 방식은** 스레드가 탐색하는 경로를 변경하지 않는다.
단지 일부 ```ClearReg``` 명령어들을 **하나의 ```SetQuant```명령어로 대체**할 뿐이다.
**새로운 필터링 알고리즘의 정당성은 다음과 같은 비공식적인 불변식(invariant)에 의존한다.**
>NFA 시뮬레이션 도중 임의의 시점에서, 어떤 스레드 𝑡, 수량자 𝑞 내부에 있는 캡처 그룹 𝑔에 대해,
𝑔의 clock 값이 𝑞의 clock 값보다 엄격히 클 때에만,
그 그룹 𝑔의 값은 해당 수량자 𝑞의 마지막 반복(iteration)에서 정의된 것이다.

이 불변식은, **캡처 그룹 _g_가 여러 개의 중첩된 수량자 내부에 있더라도 항상 성립**한다.  
또한, ```SetQuant``` 명령어는 **캡처 그룹을 포함하지 않은 수량자에는 생략될 수 있으므로, 바이트코드의 크기는 항상 이전의 ```ClearReg``` 기반 방식보다 작다.**  
이 해결책은 **NFA 시뮬레이션 엔진을 기반으로 설명되었지만,** 동일한 아이디어는 **backtracking 혹은 bit-state backtracking 구현**에도 동일하게 적용될 수 있다.
이들 구현 역시 JavaScript 의미론을 따르는 경우, **캡처 레지스터를 지우는 데 정규표현식 크기에 대해 이차 시간(quadratic time)을 소모**할 수 있기 때문이다.



### **4.3 Unrestricted JavaScript Lookarounds in Linear Time**  
이제 모든 **JavaScript lookaround(lookahead와 lookbehind, positive, negative 모두)** 를 **선형 시간에 매칭하는 알고리즘을 제안한다.** 
JavaScript의 **lookaround는 두 가지 역할을 수행**한다.
1. **매칭 필터링 (Filtering matches)**
2. **캡처 그룹 정의 (Defining capture groups)**

본 알고리즘은 이 두 역할을 **서로 다른 phase에서 분리하여 처리**한다.  
우선 첫 번째로, lookaround는 **assertion (단언식)으로서 동작하여 매칭을 필터링**한다. 
이 측면에 대해서는, **각 lookaround가 성립하는 문자열 위치를 표시하는 boolean truth table**을 미리 계산하는 **oracle 구조를 도입할 수 있음**을 보인다. 
그리고 이 oracle을 구성하는 작업을 **시간 복잡도 O(|_r_| x |_s_|)** 내에 수행할 수 있음을 증면한다.  
그 후, **주 정규표현식(main expression)** 을 매칭할 때에는, **경로가 lookaround에 도달하면 oracle을 단순히 조회**하면 된다.  
마지막 단계에서는, **lookaround 내부에서 정의된 캡처 그룹들 중 누락된 것들을 복원(reconstruct)** 한다.  
JavaScript의 **Capture Reset 속성** 덕분에, 이 작업 역시 **O(|_r_| x |_s_|)** 의 시간 내에 수행 가능함ㅇ르 보인다.  
이 알고리즘의 모든 단계 실행 예시는 부록에 제공되어 있다. 
이 알고리즘은 추가적으로 **lookaround 개수 ℓ(𝑟)와 입력 문자열 길이 |𝑠|에 비례한 공간 복잡도 O(ℓ(𝑟) × |𝑠|) 를 oracle 구조를 위해 요구한다.** 
여기서 ℓ(𝑟)은 정규표현식 𝑟 내에 포함된 lookaround의 개수로, ℓ(𝑟) ≤ |𝑟| 를 만족한다.  
이어지는 4.4절에서 **captureless lookbehind**의 특수한 경우에는 **이 공간 복잡도를 회피하는 방법**을 제시할 것이다.


#### **4.3.1 First Phase: Building the Oracle**  
본 논문에서는 정규표현식 𝑟의 **고유 크기(intrinsic size)** 를 ‖𝑟‖로 정의하며, 이는 **lookaround 내부로 재귀적으로 들어가지 않고, 텍스트로 표현된 정규표현식 자체의 크기**를 의미한다.  
다음과 같은 **내재적 등식(intrinsic equality)** 가 성립한다.
> 모든 정규표현식 𝑟에 대해, 전체 크기 |𝑟|는 고유 크기 ‖𝑟‖ 와 모든 lookaround 𝑟≶𝑖 의 고유 크기들의 합이다:  
|𝑟| = ‖𝑟‖ + ∑_{i=1}^{ℓ(𝑟)} ‖𝑟≶𝑖‖

각 lookaround 𝑟≶𝑖 이 문자열 𝑠의 어느 위치에서 매칭되는지를 모두 찾기 위해, 본 논문에서는 **NFA 시뮬레이션 알고리즘을 수정하여 O(‖𝑟≶𝑖‖ × |𝑠|) 시간 내에 oracle의 각 행(row)을 구축**할 수 있도록 한다.  
핵심 아이디어는, **𝑟≶𝑖을 문자열 뒤에서부터 역방향으로 매칭하고, 기존의 Accept 명령어를 수정하는 것이다.**
관찰점 1:  
* NFA의 최종 Accept 명령어의 **현재 문자열 위치를 기록**
* **우선순위가 낮은 스레드도 버리지 않는 명령어**로 대체하면, **NFA 시뮬레이션 알고리즘은 모든 매칭 종료 지점(position)을 찾을 수 있다.**  
이를 통해 **oracle 테이블에 기록하는 명령어인 ```WriterOracle i```를 정의한다.**

관찰점 2:  
**𝑟≶𝑖의 역방향 정규표현식** ```rev(𝑟≶𝑖)``` 를 정의한다. 이는 𝑟≶𝑖의 연결(concatenation)된 두 서브 표현식을 **재귀적으로 뒤집은 것**이다. ```/.*?rev(𝑟≶𝑖)/``` 를 문자열 𝑠를 뒤집은 것에 매칭시키면, 
원래 문자열 **𝑠에서 𝑟≶𝑖의 매칭이 시작될 수 있는 모든 위치**를 찾을 수 있다.
**lookbehind는 정방향, lookahead는 역방향으로 처리된다.**  
이 두 관찰점을 통해 **각 lookahead가 성립하는 문자열 위치 즉, 매칭이 시작될 수 있는 위치**를 계산할 수 있다. 
oracle 테이블은 **AST 상에서 가장 깊은 lookaround부터 순차적으로 행 단위로 구축**된다.  
 **중첩된 lookaround**의 경우, **내부 lookaround의 oracle 행이 먼저 계산**되며, 그 다음 **상위 lookaround**는 내부의 𝑟≶𝑖 표현식을 
**현재 문자열 위치에서 oracle을 조회하는 ```CheckOracle i``` 명령어**로 대체한다.  
이러한 방식으로, 각 lookaround 𝑟≶𝑖의 oracle 행은 **문자열에 대한 𝑟≶𝑖의 단일 매칭 실행만으로 완성**된다.  
전체 oracle 테이블을 구축하는 복잡도는 O(∑_{i=1}^{ℓ(𝑟)} ‖𝑟≶𝑖‖ × |𝑠|)이며, **내재적 등식(intrinsic equality)에 따라 이는 O(|𝑟| × |𝑠|)** 로 상한이 제한된다.


#### **4.3.2 Second Phase: Matching the main expression**  
각 lookaround가 참인 문자열 위치를 모두 계산한 후에는, **메인 정규표현식 본문을 정방향으로 실행**하면 된다.  
NFA 시뮬레이션 도중 스레드가 **lookaround에 도달하면, 단순히 oracle에서 해당 위치의 truth 값을 ```CheckOracle``` 명령어로 확인한다.**  
또한 이 명령어가 실행될 때, **각 스레드는 해당 lookaround가 마지막으로 사용된 문자열 위치를 자신의 레지스터에 기록**한다. 
이를 위해 **캡처 그룹과 마찬가지로, 각 lookaround마다 O(|_r_|)개의 레지스터가 스레드에 추가**되며, 
이는 **비대칭적 복잡도(asymptotic complexity)를 증가시키지 않는다.**  
이 단계의 전체 실행 시간 복잡도는 **O(‖𝑟‖ × |𝑠|)이며, 이때 ‖𝑟‖은 lookaround 내부를 제외한 정규표현식의 크기를 뜻한다.**  
매칭이 성공하면, 이 단계는 두 결과를 반환하는데,
1. **메인 표현식 내부에 정의된 모든 캡처 그룹의 레지스터 값들**
2. **각 lookaround가 마지막으로 사용된 문자열 위치**  

**lookaround 내부에 정의된 캡처 그룹의 값은 세 번째 단계에서 복원**된다.


#### **4.3.3 Third Phase: Reconstructing Missing Lookaround Capture Groups**  
마지막 단계에서는 **메인 매칭 결과를 생성한 바깥쪽 lookaround들 각각에 대해 NFA 시뮬레이션을 다시 실행**한다.  
**lookahead는 정방향으로 시뮬레이션, lookbehind는 정규표현식을 뒤집어서 역방향으로 시뮬레이션을 수행한다.** 
이는 lookaround 내부에서 정의된 **캡처 그룹의 의미론**을 따르기 위한 것이다.  
각 시뮬레이션은 **lookaround가 실제로 사용된 입력 문자열의 위치에서 정확히 시작**된다.  
Lookaround가 quantifier 내부에 있는 경우, **하나의 매칭 과정에서 여러 번 실행될 수도 있지만, Capture Reset 속성** 덕분에 **캡처 그룹의 값은 가장 마작 실행에서만 유효하게 정의된다.**  
시뮬레이션 도중 바깥 lookaround를 처리하다가 **내부 lookaround를 포함하고 있는 경우** ```CheckOracle```명령어를 통해 oracle을 참조하고, 해당 내부 lookaround는 **나중에 따로 실행되도록 마킹** 해둔다.  
이 새로 실행되는 시뮬레이션의 **winning thread가 누락된 캡처 그룹의 값을 최종적으로 정의한다.**  
이 단계는 **최악의 경우 각 lookaround에 대해 한 번씩 NFA 시뮬레이션을 실행**해야 하며, 총 시간 복잡도는 O(|_r_| x |_s_|)이다.    
Figure 11은 알고리즘 1에 대해 ```WriteOracle``` 및 ```CheckOracle``` 명령어를 **어떻게 추가할 수 있는지 보여준다.** 
여기서 주의할 점은 ```WriteOracle```은 **Accept 명령어와 달리, 우선순위가 낮은 다른 스레드를 죽이지 않고 현재 스레드만 종료**한다.  

정당성(Correctness)  
관찰점 1: ```WriteOracle```의 동작은 **uniform-futures property**를 기반으로 보장됨.  
관찰점 2: 정규표현식에 대한 **귀납적 증면(induction)** 으로 정당성 확보
1단계, 2단계의 정당성은 관찰점 1, 2와 **기존 NFA 시뮬레이션 알고리즘의 정당성**으로부터 자동으로 따라온다.  
3단계의 정당성은 다음 사실에 근거함: Capture Reset 속성에 따라, lookaround 내부의 캡처 그룹은 해당 lookaround가 winning thread에서 마지막으로 실행될 때만 유효하게 정의된다.  


### **4.4 Matching Captureless Lookbehinds with an NFA Simulation**

---

### Notes

#### 4.1 Matching JavaScript Nullable Quantifiers in a Linear Engine  
**핵심 배경: JavaScript만의 nullable 수량자 의미론**
* 대부분의 정규표현식 언어는 *, +와 같은 수량자가 **빈 문자열과 매치될 수 있음**을 허용
* **JavaScript는 "선택적 반복(optional repetition)"이 빈 문자열과 매치되는 것을 허용하지 않음**
* 이는 nullable quantifier에 대해 **다른 언어와는 의미론적으로 다른 동작을 유도함.** (**백트래킹 구현에서 무한 루프를 방지하기 위함**)

**문제 상황**
* 기존의 **NFA 시뮬레이션 기반 선형 엔진(e.g., V8Linear)** 은 **uniform-futures property**를 기반으로 함.
  * 동일 state, position 재방문 → discard (processed 배열로 중복 실행 방지)
* JavaScript 의미론에서는, **수량자 내부에서 이전에 문자를 소비했는지 여부**에 따라 동일 상태여도 **재방문 가능/불가능 여부가 달라짐**
  * 즉, **과거 이력을 고려해야 함 → uniform-futures property 위반**

**해결 아이디어: 오토마타 복제**  
* **각 정규표현식 상태를 두 번 복제**하여 두 개의 오토마타로 분리
  * **왼쪽 오토마타(_s_<sub>_i_</sub>)**: 모든 상위 수량자에서 문자를 소비한 경우 **→ 탈출 허용**
  * **오른쪽 오토마타(_t_<sub>_i_</sub>)**: 아직 문자를 소비하지 않음 **→ 탈출 불가**
* **수량자 시작 시:** BeginLoop 명령어 → 오른쪽 오토마타로 진입
* **문자 소비 시:** 전이 시 자동으로 왼쪽 오토마타로 복귀
* **수량자 종료 시:** EndLoop 명령어
  * 왼쪽에서는 Jump처럼 동작
  * 오른쪽에서는 **스레드 차단(blocking)**

**최적화: 실제 구현에서 복제는 불필요**
* 실제 엔진에서는 **오토마타 복제를 하지 않음**
* 대신, 각 **스레드에 left라는 boolean 필드를 추가**
  * 현재 스레드가 왼쪽/오른쪽 오토마타 중 어디에 속해 있는지 추적
  * BeginLoop, Consume, EndLoop가 이 boolean 값을 갱신/참조

**정당성(Correctness)**
* **수량자는 항상 well-parenthesized**되어 있음
  * 가장 안쪽 수량자만 종료되고, 바깥 수량자는 그대로 유지됨
* 따라서, **오토마타 복제를 두 번만 하면 충분**하며, 어떠한 중첩 상황에서도 JavaScript 의미론을 완전히 반영할 수 있음

**일반화 및 적용 확장**
* 본 접근은 NFA 시뮬레이션뿐 아니라, **Bit-state backtracking, Lazy DFA simulation**에도 적용 가능
* **Counted Repetition ({m, n})** 에도 동일한 방식으로 적용 가능


#### 4.2 Linear Matching of the Capture Reset Property  
**핵심 목적**
* JavaScript 정규표현식의 고유 의미론인 **Capture Reset**을 _선형 시간 (O(|r|))_ 안에 처리할 수 있는 **NFA 기반 알고리즘** 제안.
* 기존 V8Linear 구현은 **수량자 내의 캡처 그룹 초기화(CleaReg)** 로 인해 **이차 시간 복잡도(O(|r|^2))** 발생.

**문제점: 기존 방식의 한계**  

| 항목       | 내용                                            |
|----------|-----------------------------------------------|
| 기존 방식    | 수량자 진입 시마다 각 캡처 그룹에 대해 ```ClearReg``` 명령어를 삽입 |
| 문제 발생 원인 | 정규표현식 AST 상에서 수량자가 중첩될수록 **ClearReg 수가 많아짐**  |
| 결과       | 정규표현식 크기                                      |

정규표현식 계열 r₀ = /./, rₙ₊₁ = /(rₙ)*/ → |rₙ| = O(n) 이지만, 바이트코드는 O(n²)

**새로운 해결책: Capture Reset의 선형 구현**

| 구성 요소   | 설명                                                                             |
|---------|--------------------------------------------------------------------------------|
| 핵심 아이디어 | **모든 스레드에서 Clear를 하지 않고,** 매칭 완료 후 **winning thread만 필터링**                     |
| 시간 추적   | **global clock 도입**: 모든 명령어 실행 시마다 증가하는 정수 값                                   |
| 레지스터 확장 | 스레드별로 아래 두 정보 저장<br/> gclocks: 캡처 그룹마다 마지막 설정 시간 <br/> qclock: 수량자마다 마지막 진입 시간 |
| 필터링 기준  | 그룹 g의 clock > 수량자 q의 clock → g는 유효, 아니면 무효화(clear)                             |
| 명령어 추가  | ```SetReg``` → 캡처 시작 시간 기록 <br/>   ```SetQuant q``` → 수량자 진입 시 시간 기록 <br/>          |

**예시**  
정규표현식: / (a)* | (b) | (c)* */  
문자열: "abc"
Clock 비교:
- (a)는 외부 star보다 clock 값 작음 → 무효화
- (b)도 마찬가지 → 무효화
- (c)는 가장 늦게 설정됨 → 유지


**정당성(Correctness)**  
불변식 유지
* ∀ thread t, ∀ group g ⊆ quantifier q:  
  clock(g) > clock(q) ⇔ g는 q의 마지막 반복에서 설정됨
* **중첩 수량자**에도 적용 가능
* **캡처 없는 수량자에는 ```SetQuant``` 생략 가능 →** 더 작은 바이트 코드
* **Backtracking / Bit-state backtracking에도 일반화 가능**


**고려사항**  
* **Backreference가 있는 경우:**  
  → 동적으로 캡처 그룹을 clear 해야 정확한 참조 가능  
  → JavaScript에서는 undefined된 그룹을 참조할 경우 빈 문자열로 매칭됨


---

## **V.**


---
### Notes


---

## **VI.**


---
### Notes


---
## **VII.**


---
### Notes


---
## **VIII.**


---
### Notes

---

> ### Profile
>
>
> ***Seong Hun KIM***
>
>
> **M.S. course**  
> **Dept. of Computer Science Engineering | Yeungnam University, Repulic of Korea**
>
> ![yu signature](https://github.com/HoonC-corgi/Convolution_Filter_Application/assets/118245330/37c81d9e-cfb8-4aee-8497-ff1071b2458b)
>
> **Phone** [010 - 6685 - 1140](tel:010-6685-1140)  
> **Mail** [tgh7544@naver.com](mailto:tgh7544@naver.com)  
> **LinkTree** [https://linktr.ee/HoonC_corgi](https://linktr.ee/HoonC_corgi)














